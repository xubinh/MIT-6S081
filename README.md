# lock

## Memory allocator (moderate)

思路:

- 为每个 CPU 维护各自独立的空闲链表以及对应的自旋锁. 如果当前 CPU 的空闲链表为空, 那么**释放该链表的自旋锁** (以避免造成死锁) 并从其他 CPU 的空闲链表中偷取内存. `kernel/param.h` 文件中定义了 CPU 总数 `NCPU`; `cpuid` 函数可用于返回当前 CPU 的 id, 但必须在使用之前将中断关闭并在之后恢复中断, 这可以通过函数 `push_off` 和 `pop_off` 做到.
- `freerange` 函数必须进行相应的修改以便所有空闲块被归还到当前 CPU 的空闲链表中.
- 根据实验要求, 必须为每个自旋锁设置一个名称, 并且必须以 "kmem" 开头. 直接使用 `kmem-<cpu-id>` 即可. 可以使用 `kernel/sprintf.c` 文件中的 `snprintf` 函数进行字符串打印.

## Buffer cache (hard)

思路:

- 由于 block 需要在进程间 (因而在 CPU 间) 进行共享, 因此无法像 kalloc 中那样通过为每个 CPU 设置独立的链表来解决, 而必须维护一个全局的 block 数组. 但虽说仍然要维护全局数组, 我们完全可以对缓存命中与缓存不命中这两个操作赋予不同的竞争粒度. 具体而言, 我们使用哈希表将不同的 block number 分散到各个桶中来减小查询的粒度. 桶的数量暂时可以取定值, 一般取素数以便尽可能降低哈希冲突的概率, 例如可取素数 13 等.
- 由于缺少 malloc 这样的基础设施, 哈希表的 node 可以像 buf 那样从一个静态数组中进行生成, 每个 node 和一个 buf 一一对应.
- 为了进一步提高局部性并降低竞争性, 即使一个 block 的引用计数降为零, 我们也应当暂时将其保留在哈希表中. 这样如果没有任何其他进程想要将该块作为空闲块取走, 那么当下一次请求到来的时候我们仍然能够以常数时间和最低的竞争获取到该块. 如果确实存在其他进程将其取走, 那么这个进程在取走该块之前必须获取该块所属的桶的锁, 确保当前进程下一次查询的时候能够正常触发缓存不命中.
- 为了降低竞争性, 可以将 LRU 缓存的簿记机制从双向链表形式改为时间戳形式, 每个 block 的时间戳更新的粒度降低至以桶的锁为单位 (更新时机在 `brelse` 函数中), 但空闲 block 的寻找仍然通过全局的 `bcache.lock` 进行同步.
  - 时间戳可以使用 `kernel/trap.c` 文件中定义的 `ticks` 函数来生成. 注意在获取时间戳之前首先获取锁.
- 由于我们在检查桶的时候需要获取当前桶的锁, 并且在缓存未命中的时候需要从别的桶中获取空闲块, 如果在获取别的桶的锁之前没有释放当前桶的锁, 那么易知此时将导致死锁的情况发生; 而如果在获取别的桶的锁之前释放了当前桶的锁, 那么就有可能出现两个不同的进程都认为某一个块缓存未命中进而一前一后各自带回来一个空闲块的情况. 为了解决这一问题, 我们可以采用经典的双重检查的模式, 即在缓存未命中时释放桶的锁, 然后通过获取全局的 `bcache.lock` 锁进行线性同步, 并再一次获取桶的锁, 此时再进行检查就必然能够保证最终只有一个进程负责取空闲块, 而其他进程将看到空闲块已经被取回来于是能够立即返回.

### 调试过程流水账

```text
scause 0x000000000000000f
sepc=0x00000000800031de stval=0x0000000000000000
panic: kerneltrap

gdb

file kernel/kernel

x/10i 0x800031de

ctrl + l

disassemble /m binit
```
