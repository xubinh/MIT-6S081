# mmap

## Lab: mmap (hard)

前置知识:

- Linux 中 (包括本实验中) 的 mmap 函数的签名为 `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`, 其中:
  - `addr`: 由用户指定所映射区域的起始虚拟内存地址. **本实验中可假设该参数总是 `NULL`, 意思是让内核决定所映射区域的起始地址. mmap 函数的返回值便是该地址 (在失败的情况下则为 `0xffffffffffffffff`)**.
  - `length`: 用户想要映射的区域的大小. 例如所传入的文件的大小为 1000 KB, 那么用户可以选择映射该文件的前 500 KB, 也可以选择映射一整个文件.
  - `prot`: 由用户指定所映射内存区域的访问权限, 包括是否可读 (`PROT_READ`), 是否可写 (`PROT_WRITE`), 以及是否可执行三种. **本实验中只需要实现前两种**.
  - `flags`: 指定本次内存映射的特性. 可选项包括 `MAP_SHARED` (意思是对内存映射区域的更改将写回所映射的文件) 和 `MAP_PRIVATE` (意思是对内存映射区域的任何更改均被丢弃) 等等. **本实验中只需要实现这两种特性**.
  - `fd`: 所要映射的文件的文件描述符.
  - `offset`: 用户想要对文件进行映射的区域的起始位置在文件中的偏移. **本实验中可以假设该偏移总是零**.

  Linux 中 (包括本实验中) 的 munmap 函数的签名为 `int munmap(void *addr, int length);`, 其中:
  
  - `addr`: 用户想要取消映射的区域的起始地址.
  - `length`: 用户想要取消映射的区域的长度.

  注意事项:

  - 如果映射区域内的某个内存块被修改, 并且映射区域的特性为 `MAP_SHARED`, 那么 munmap 将负责写回该内存块至文件中.
  - **本实验中可以假设 munmap 总是取消映射一个区域的开头或末尾, 而不会在区域的中间进行取消映射 (即不会在区域的中间打个洞)**.

思路:

- [x] 向 Makefile 中添加 `mmaptest`.
- [x] 添加 `mmap` 和 `munmap` 的用户接口.
- [x] 添加 `mmap` 和 `munmap` 的系统调用定义.
- [x] 使用 VMA (virtual memory area) 数据结构来记录每一个内存映射区域. 一个 VMA 需要记录映射区域的起始地址, 长度, 映射特性 (将修改写回还是丢弃), 访问权限 (是否可读可写), 以及所映射的文件等等. 由于 xv6 并不支持动态内存分配, 因此可以预先定义一个定长的 VMA 数组用于所有进程的 mmap. 本实验中定义一个长度为 16 的 VMA 数组即可.
- [x] 实现 mmap:
  - 将 `mmap` 实现为惰性加载 (类似于 `sbrk`), 并将内存映射逻辑放至缺页异常处理函数中.
  - 每个进程的所有 mmap 区域必须位于 `MMAPBASE` (其值等于 `0x60000000L`) 之上, 以便和堆区域之间空出足够的内存空间.
  - 在每个进程中维护一个进程独立的 VMA 数组. 当用户调用 `mmap` 时将根据进程的 VMA 数组寻找映射区域的起始地址.
  - mmap 需要调用 `filedup` 递增给定的 `struct file` 对象的引用计数.
    - 注: mmap 与文件描述符共享一个 `struct file` 对象, 类似于系统调用 `dup`.
  - 所有映射的内存区域的权限初始时均设置为不可读且不可写 (并且总是不可执行), 以便在用户试图读写该区域时能够触发缺页异常.
- [x] 在缺页异常处理函数中添加逻辑:
  - 检查用户是否拥有执行所要求的操作的权限.
  - 分配一块新的物理内存.
  - 调用 `readi` 函数从文件中读取物理块并复制到该物理内存中.
  - 更改 PTE, 映射物理块至用户内存空间中, 并恢复权限.
- [x] 修改 sbrk 系统调用使其在堆内存区域超出 `MMAPBASE` 时报错.
- [x] 实现 munmap:
  - 根据进程的 VMA 数组寻找到指定的映射区域, 并调用 `uvmunmap` 函数对指定范围进行取消映射.
    - 如果本次操作将一个完整的映射区域取消映射, 那么还需要递减对应的 `struct file` 的引用计数.
    - 如果内存区域被修改, 那么还需要调用 `writei` 函数将其写回文件. 此外还可以通过检查 PTE 中的脏位 (dirty bit) `PTE_D` 来判断一个页面是否被修改.
      - 脏位由 CPU 自动设置, 因此直接检查即可.
      - **本实验并不要求判断脏位**, 因此直接写回任何取消映射的区域也无妨.
- [x] 修改 `exit` 使其对当前进程的所有映射区域进行取消映射 (等价于直接执行 munmap).
- [x] 修改 `fork` 使其复制父进程的 VMA 以及所有映射区域, 并递增 `struct file` 对象的引用计数.
- [x] 如果映射区域的长度大于文件的长度则需要将物理内存块中的剩余部分置为零. 这可以通过判断从文件中读取出的字节数是否等于期望的字节数来确定.
- [x] 即使一个文件以只读权限打开, mmap 也应该能够在 `MAP_PRIVATE` 模式下对**内存中的**文件副本进行写入.
