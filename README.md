# lazy

## Eliminate allocation from sbrk() (easy)

(略)

## Lazy allocation (moderate)

大纲:

- [x] 首先需要一种对异常的类型进行查询的手段. 异常的类型由 `scause` 寄存器所指示, 而读缺页异常和写缺页异常的编号分别为 13 和 15.
- [x] 其次需要知道用户想要读写的虚拟地址是什么. `stval` 寄存器中包含有转换失败的虚拟地址, 因此直接查看该寄存器即可.
- [x] 获取了引发缺页异常的虚拟地址之后需要将其转换为 4096 KB 对齐的页面首地址, 并进行物理页面分配和虚拟页面映射.
- [x] 此外 `uvmunmap` 函数的原始设计假设进程的内存段是连续的, 在惰性分配的情况下这一假设将会失效, 因为可能出现一大段内存均为惰性分配并且还未分配, 而这一大段内存当中的某一个页面却被分配了的情况, 此时进程的内存段就不再是连续的了, 因此我们需要修改 `uvmunmap` 函数的实现使其适应这种情况.

## Lazytests and Usertests (moderate)

大纲:

- [x] 使用修改后的 `uvmunmap` 函数和 `uvmdealloc` 函数正确处理 `n` 为负时的 `sbrk` 调用.
- [x] 如果一个进程要求访问非法的虚拟地址, 则第一时间将其杀死.
- [x] 修改 `fork` 函数使其正确处理离散内存段的情况.
- [x] 除了在用户空间触发缺页异常的时候进行物理页面分配, 我们还需要确保内核代码也能够正确处理惰性分配. 由于内核代码是手动进行虚拟地址转换的, 无法触发陷入, 因此必须在各个系统调用中分别进行处理. 具体需要修改的系统调用包括:
  - `sys_read`;
  - `sys_write`;
  - `sys_pipe`.
- [x] 如果**在缺页异常处理函数中**尝试分配物理页面时遇到内存不足的情况, 则直接将当前进程杀死.
- [x] **在 `sys_sbrk` 中统一使用 `uint64` 类型来进行大小计算, 否则将无法通过 `lazytests` 中的 `oom` (out of memory) 测试**.
  - 无法通过的原因是在测试主进程所 fork 出来的子进程中的每一次 `malloc` 将会 sbrk 一块长为 $4096 * 4096 = 2^24$ 字节的内存, 但只用到了其中的一块物理页面, 即只真正分配了 $2^12$ 字节的内存. 为了真正耗尽 $128 * 1024 * 1024 = 2^27$ 字节的可用物理内存, 我们需要调用 `malloc` 共计 $2^{27 - 12} = 2^15$ 次, 从而使得当前子进程的逻辑内存大小达到 $2^15 * 2^24 = 2^39$ 字节, 这已远远超出了 `int` 类型所能表示的范围, 而当前子进程最终将会因为 `sbrk` 失败而正常返回, 这并不是测试主进程所期望的, 测试主进程希望看到的是子进程由于 OOM 而被杀死 (这也是为什么测试主进程的退出状态码是 `exit(xstatus == 0);` 的原因), 而不是子进程正常退出.
- [x] 在检查引发缺页异常的虚拟地址是否合法的时候我们还需要检查该地址是否位于用户栈页面下方的哨兵页面, 因为该页面实际上已经分配了物理页面, 只不过因其有效位在一开始被置零从而导致触发缺页异常. 为了判断当前是否在尝试访问该哨兵页面, 我们只需要判断当前试图访问的虚拟地址是否位于栈顶指针 `sp` 的下方 (低地址方向) 即可, 因为 `sp` 的下方除了哨兵页面就是程序的文本 (代码) 段, 而程序在载入的时候其文本段部分的物理页面总是已经提前分配好了的, 因此只要触发了缺页异常就必然是在试图访问哨兵页面. **如果程序确实在访问哨兵页面则需要将其杀死, 否则将无法通过 `usertests` 中的 `stacktest` 测试**.
