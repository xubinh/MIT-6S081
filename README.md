# util

## Boot xv6 (easy)

大纲:

- [x] 搭建环境.
- [x] 克隆仓库.
- [x] `git checkout` 至 `util` 分支.
- [x] `make qemu` 开机.

注意事项:

- 可以使用 `ls` 命令列出当前目录下的文件.
- xv6 中没有 `ps` 命令, 可以使用 `Ctrl-p` 替代.
- 输入 `Ctrl-a` + `x` 即可退出 xv6.

## sleep (easy)

内核中与进程睡眠有关的核心函数是位于文件 `kernel/proc.c` 中的 `sleep` 函数 (以下代码摘自该文件):

```c
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
  struct proc *p = myproc();
  
  // Must acquire p->lock in order to
  // change p->state and then call sched.
  // Once we hold p->lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup locks p->lock),
  // so it's okay to release lk.
  if(lk != &p->lock){  //DOC: sleeplock0
    acquire(&p->lock);  //DOC: sleeplock1
    release(lk);
  }

  // Go to sleep.
  p->chan = chan;
  p->state = SLEEPING;

  sched();

  // Tidy up.
  p->chan = 0;

  // Reacquire original lock.
  if(lk != &p->lock){
    release(&p->lock);
    acquire(lk);
  }
}
```

- `sleep` 函数用于原子性地将进程挂起并让出执行权给调度器, 然后等待被调度器重新唤醒.
- 参数 `chan` 即 `channel`, 表明进程所睡眠在的队列, 但这个 "队列" 是逻辑上的队列, 实际上内核直接使用一个指针来标记队列, 并未使用任何其他数据结构.
- 参数 `lk` 即 `lock`, 是进程在请求睡眠之前需要获取的锁.

文件 `kernel/sysproc.c` 中的系统调用 `sys_sleep` 的作用是获取用户传入的 tick 数, 然后调用上述 `sleep` 函数 (以下代码摘自该文件):

```c
uint64 sys_sleep(void) {
    int n;
    uint ticks0;

    // 获取用户传入的参数中的第一个参数并解释为 int 类型
    if (argint(0, &n) < 0) {
        return -1;
    }

    // 计时开始
    acquire(&tickslock);
    ticks0 = ticks;

    // 不断睡眠, 直至超出预定时间
    while (ticks - ticks0 < n) {
        if (myproc()->killed) {
            release(&tickslock);
            return -1;
        }

        sleep(&ticks, &tickslock); // 此处调用了核心函数 `sleep`
    }

    release(&tickslock);

    return 0;
}
```

用户库 `user/user.h` 中的系统调用接口如下:

```c
int sleep(int);
```

文件 `user/usys.S` 中存储的是一些从用户端的系统调用跳转到系统端对应的真实函数的汇编代码:

```assembly
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
// ...
.global sleep
sleep:
 li a7, SYS_sleep
 ecall
 ret
// ...
```

可以看到系统调用 `sleep` 会跳转到对应的内核函数 `SYS_sleep` 即 `sys_sleep`.

为了实现用户版本的 `sleep` 函数, 需要 (1) 获取并检查参数, 必要时输出错误信息, 然后 (2) 调用系统调用版本的 `sleep` 函数.

注意事项:

- **`main` 函数必须以系统调用 `exit` 结尾**.
- 可以使用 `user/ulib.c` 中的 `atoi` 函数将字符串转换为整数.
- 完成后将 `sleep` 函数追加到 Makefile 中的 `UPROGS` 变量中 (这个变量中包含的是一系列用户可调用的二进制程序, 例如 `echo` 和 `grep` 等等). 注意添加的形式是 `_sleep` 而不是 `sleep`. 之后 `make qemu` 会负责编译这个函数并能够在 shell 中调用该函数.
- 如果在编译的时候提示缺失如 `uint` 之类的类型, 这是因为 xv6 的源码中头文件的 include 是依赖先后顺序的, 可以通过在头文件中添加 `#ifndef` 预处理命令并手动 include 的方法解决.

## pingpong (easy)

实验要求很明确, 目的是为了熟悉 `fork` 创建进程, `pipe` 创建命名管道以便进程间通信, `read` 和 `write` 进行读写, `getpid` 获取当前进程 ID.

关于命名管道:

- 一个管道由两个文件描述符构成, 一个用于读, 另一个用于写.
- 当进程 `fork` 时, 由于文件表同时在父进程和子进程中留有副本, 因此负责读的进程必须关闭管道中的写描述符, 否则该进程将永远无法读到 EOF.

至于输出信息, 需要用到 `printf` 函数, 这个函数要去 `user/printf.c` 中查看.

注意事项:

- `printf` 只识别 `%d, %x, %p, %s`.

## primes (moderate)/(hard)

实验要求实现一个埃氏筛法来打印素数, 但不是通过一般的循环语句实现, 而是通过进程间通信的形式将本轮循环中的结果传递给下一个进程处理.

思路:

- 父进程可以使用 `wait` 系统调用等待所有子进程退出.
- 主进程和所有子进程的分工很明确, 前者负责启动子进程链并输入所有整数, 每个子进程负责从自己的父进程读取输入, 输出传入的第一个整数即素数, 然后一旦发现有整数没有被筛掉便创建一个子进程并将该整数和接下来所有没有被筛掉的整数输入给该子进程.
- 关键是如何配合 `fork` 编织子进程的逻辑. 由于每个新创建的子进程均需要重新回到相同的入口开始执行, 因此可以用函数将子进程的逻辑抽象出来并在 `fork` 之后调用. 但这样做会导致用户栈随着子进程链的推进而不断增大, 因此可以选择通过 `while` 循环配合 `continue` 或者直接 `goto` 的方法实现.

注意事项:

- 注意使用 `wait` 等待的是直接子进程, 子进程创建的子进程不算在父进程的直接子进程中.
- 父进程需要在等待子进程之前将管道的写端先关闭, 否则子进程会由于读取不到 EOF 而一直阻塞从而卡死整个进程.

## find (moderate)

实验的目的是为了熟悉文件系统相关的系统调用以及文件路径处理.

思路很简单, 如果是文件并且能够被模式匹配则输出, 如果是目录则递归调用自身.

一些帮手函数:

- `memmove(des, src, srclen)`
- `memset(des, c, len)`
- `strcpy(des, src)`
- `strlen(str)`

目录的定义:

```c
// Directory is a file containing a sequence of dirent structures.
#define DIRSIZ 14

struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
```

文件元数据结构类型 `stat` 的定义:

```c
#define T_DIR 1    // Directory
#define T_FILE 2   // File
#define T_DEVICE 3 // Device

struct stat {
    int dev;     // File system's disk device
    uint ino;    // Inode number
    short type;  // Type of file
    short nlink; // Number of links to file
    uint64 size; // Size of file in bytes
};
```

注意事项:

- 务必记得排除 `.` 和 `..` 这两个目录, 避免循环遍历.
- 对字符串进行操作时务必仔细分析, 稍有不慎就会造成微妙难以察觉的 BUG.
- `stat` 和 `fstat` 函数分别用于通过文件名和文件描述符获取文件元数据, 主要用于区分文件是普通文件还是目录文件.
- `open` 函数用于打开目录文件并读取条目, 条目的类型为 `dirent`, 其中包含文件名.

## xargs (moderate)

要求实现一个简单版本的 `xargs` 程序, 作用是从标准输入读取文本, 将文本内容中的每一行作为一个单独的参数传递给 `xargs` 的参数所指明的程序. 通过 `xargs` 的参数可以为所指明的程序预先指定若干个固定参数, 而从 `xargs` 的标准输入中读取到的单独参数应该追加在这些固定参数之后. 例如:

```bash
echo "1 2\n3 4" | xargs echo line
```

应当输出

```text
line 1 2
line 3 4
```

注意从标准输入中读取的文本不需要对每一行进行分割, 而是视作一个单独的参数传递给所指定的程序.

思路很简单, 主进程负责读取标准输入, 获取传入的指定程序和参数, 循环构建子进程的命令行参数数组并调用 `fork`. 子进程负责调用 `exec` 执行指定程序, 父进程负责等待子进程完成并继续下一轮循环.

注意事项:

- 读取标准输入的时候可以选择带缓冲区地处理, 也可以选择逐字符读取并在遇到换行符的时候切断.
- 构建子进程的 argv 的时候可以使用 `kernel/param.h` 中定义的 `MAXARG` 宏指定数组大小.
- 一定要注意传递给子进程的可执行文件名位于 `xargs` 的 `argv` 数组的下标为 1 的字符串中, 如果错将下标为 0 的字符串传入给子进程会造成递归调用并产生意想不到的效果.
- 在 `exec` 系统调用中, 遍历传入的 `argv` 时一旦遇到空指针则停止, 因此可以将 `argv` 初始化为全 0 来起到和额外传入一个 `arvc` 一样的作用.

## 测试相关

运行所有测试:

```bash
make grade
```

运行单个测试:

```bash
# 方法一:
./grade-lab-util <function-name>

# 方法二:
make GRADEFLAGS=<function-name> grade
```

也可以通过在 qemu 内部直接运行 usertests 来进行测试.
